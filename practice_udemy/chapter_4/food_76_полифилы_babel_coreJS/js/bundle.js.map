{"version":3,"file":"bundle.js","mappings":";;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,CAAC,KAA4D;AAC7D,CAAC,CAC+B;AAChC,CAAC,sBAAsB;;AAEvB;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;AAIA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,gFAAgF;;AAEhF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,2BAA2B,qBAAqB;;AAEhD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kBAAkB,SAAS;AAC3B;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA,EAAE;AACF;AACA,EAAE,wCAAwC,UAAc;AACxD;AACA,EAAE;AACF;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;;AAGA;AACA;AACA;AACA;AACA,KAAK;AACL,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;AACH;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA,UAAU,KAAK;AACf;AACA,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,kBAAkB,wBAAwB;AAC1C;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA,oBAAoB,6CAA6C;AACjE;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;;AAEA;AACA;AACA,QAAQ;AACR;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,SAAS;AACT;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA,QAAQ;AACR;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;;AAEA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;;AAEA;AACA;AACA,UAAU,OAAO;AACjB,UAAU,QAAQ;AAClB;AACA,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;;AAEH;AACA;AACA;AACA,KAAK;AACL,GAAG;;AAEH;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;;AAEH;AACA;AACA;AACA,KAAK;AACL,GAAG;;AAEH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,UAAU,OAAO;AACjB;AACA,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL,IAAI;AACJ;AACA;AACA,sBAAsB,YAAY;AAClC;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;;AAEA;AACA;AACA,UAAU,KAAK;AACf;AACA,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;;AAEA;AACA,UAAU,UAAU;AACpB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,SAAS;AACT,QAAQ;AACR;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA,UAAU,UAAU;AACpB,UAAU,UAAU;AACpB;AACA,WAAW;AACX;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,UAAU,UAAU;AACpB;AACA,WAAW;AACX;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA,YAAY,UAAU;AACtB,aAAa;AACb;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA,SAAS;AACT,OAAO;AACP;;AAEA;AACA;;AAEA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,aAAa,qBAAM;AACnB,YAAY,qBAAM;AAClB,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,CAAC;;;;AAID;;;;;;;;;;;;;;;;ACrpCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe,IAAI;;;;;;;;;;;;;;;AC5HnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8FAA8F,SAAS,SAAS,SAAS,oCAAoC,WAAW,sCAAsC,iBAAiB,4JAA4J,UAAU;AACrY;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB,wEAAwE;AACxE;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC,mCAAmC;AACnC;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA,sBAAsB;AACtB,8DAA8D;AAC9D;AACA;AACA;AACA,mCAAmC,SAAS,SAAS,SAAS;AAC9D,yDAAyD,WAAW;AACpE;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA,iEAAiE,WAAW;AAC5E;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA,wBAAwB;AACxB,oFAAoF;AACpF;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA,mCAAmC;AACnC,mCAAmC;AACnC;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA,sBAAsB;AACtB,8DAA8D;AAC9D;AACA,gDAAgD;AAChD;AACA,gDAAgD;AAChD,wDAAwD;AACxD;AACA,iBAAiB;AACjB,wFAAwF;AACxF;AACA;AACA;AACA;AACA,+BAA+B,SAAS,SAAS,SAAS;AAC1D,qDAAqD,WAAW;AAChE;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA,6DAA6D,WAAW;AACxE;AACA;AACA;AACA,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C,uCAAuC;AACvC;AACA,0BAA0B;AAC1B,kDAAkD,IAAI,YAAY,WAAW;AAC7E;AACA,oCAAoC;AACpC;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B,mGAAmG;AACnG;AACA;AACA,mBAAmB;AACnB,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,4FAA4F;AAC5F;AACA;AACA,YAAY;AACZ,QAAQ;AACR;AACA,mCAAmC;AACnC,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ,8DAA8D;AAC9D,oDAAoD;AACpD;AACA;AACA,+BAA+B,IAAI,SAAS,OAAO;AACnD,qDAAqD,MAAM;AAC3D;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA,6DAA6D,MAAM;AACnE;AACA;AACA;AACA,2EAA2E;AAC3E,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA,iEAAe,KAAK;;;;;;;;;;;;;;;;;AC9PH,CAAC;AAGY;AAC9B;AACA;AACA;AACA;AACA,0DAA0D;AAC1D,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B,4BAA4B;AAC5B;AACA,KAAK;AACL;AACA;AACA;AACA,kCAAkC;AAClC,iDAAiD;AACjD;AACA,gCAAgC;AAChC;AACA,iEAAiE;AACjE,iDAAiD;AACjD;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C;AACA,mEAAmE;AACnE;AACA;AACA;AACA;AACA,qDAAqD;AACrD,mDAAmD;AACnD,6EAA6E;AAC7E;AACA;AACA,iDAAiD;AACjD;AACA;AACA,kCAAkC;AAClC;AACA,wDAAwD;AACxD,wCAAwC;AACxC,gBAAgB;AAChB;AACA,iFAAiF;AACjF;AACA;AACA,oDAAoD;AACpD;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA,YAAY,4DAAQ;AACpB,gCAAgC;AAChC,uCAAuC;AACvC,sDAAsD;AACtD,4CAA4C;AAC5C,iBAAiB;AACjB,+BAA+B;AAC/B;AACA;AACA,sDAAsD;AACtD,iBAAiB;AACjB,iCAAiC;AACjC,kCAAkC;AAClC,iBAAiB;AACjB;AACA,wDAAwD;AACxD,iDAAiD;AACjD,sDAAsD;AACtD,yDAAyD;AACzD,qCAAqC;AACrC,+CAA+C;AAC/C,qBAAqB;AACrB,yDAAyD;AACzD;AACA,gBAAgB;AAChB,SAAS;AACT;AACA;AACA;AACA;AACA,wCAAwC;AACxC,0EAA0E;AAC1E;AACA,+CAA+C;AAC/C,QAAQ,iDAAS,0BAA0B;AAC3C;AACA,2DAA2D;AAC3D,oDAAoD;AACpD;AACA;AACA;AACA,gEAAgE;AAChE,gDAAgD,QAAQ;AACxD;AACA;AACA;AACA;AACA,8DAA8D;AAC9D,2BAA2B;AAC3B,kCAAkC;AAClC,mDAAmD;AACnD,sDAAsD;AACtD,YAAY,kDAAU,YAAY;AAClC,SAAS,SAAS;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe,KAAK,EAAC;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA,6BAA6B,aAAa;AAC1C,kBAAkB;AAClB;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C;;;;;;;;;;;;;;;;;AC7K7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD;AAClD;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC,kDAAkD;AAClD,2DAA2D;AAC3D,qDAAqD;AACrD,YAAY;AACZ,QAAQ;AACR,kDAAkD;AAClD,+CAA+C;AAC/C,yDAAyD;AACzD,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,+DAA+D;AAC/D;AACA;AACA,kCAAkC;AAClC;AACA,4CAA4C;AAC5C,+CAA+C;AAC/C,wDAAwD;AACxD;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,sDAAsD;AACtD,uCAAuC;AACvC,0CAA0C;AAC1C,8CAA8C;AAC9C;AACA,QAAQ;AACR;AACA,4DAA4D;AAC5D;AACA,mDAAmD;AACnD,+EAA+E;AAC/E;AACA,2CAA2C;AAC3C,8CAA8C;AAC9C,kDAAkD;AAClD,uCAAuC;AACvC;AACA,KAAK;AACL;AACA,kDAAkD;AAClD,uEAAuE;AACvE;AACA,uCAAuC;AACvC;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA,qEAAqE;AACrE;AACA;AACA;AACA;AACA,0DAA0D;AAC1D;AACA;AACA;AACA;AACA;AACA,iEAAe,KAAK,EAAC,CAAC;AAGpB;AAGA,CAAC;;;;;;;;;;;;;;;AC/GH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,IAAI;AAC9D,yBAAyB;AACzB,yDAAyD,IAAI;AAC7D;AACA,qBAAqB;AACrB;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,WAAW;AAC9C,aAAa;AACb,kCAAkC,WAAW;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,QAAQ;AAClE,yBAAyB;AACzB,yDAAyD,QAAQ;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,QAAQ;AAC9D,qBAAqB;AACrB,qDAAqD,QAAQ;AAC7D;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D;AAC9D;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,cAAc;AAC9C,kCAAkC,WAAW;AAC7C,MAAM;AACN;AACA;AACA;AACA;AACA,yDAAyD;AACzD;AACA,wCAAwC;AACxC,+CAA+C;AAC/C;AACA,6CAA6C;AAC7C;AACA,8BAA8B;AAC9B,mCAAmC;AACnC,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,mBAAmB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C;AACA,sEAAsE;AACtE;AACA;AACA;AACA,wBAAwB;AACxB,UAAU,OAAO;AACjB,8CAA8C;AAC9C;AACA;AACA,qDAAqD,OAAO;AAC5D;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,sCAAsC,WAAW;AACjD,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,2CAA2C;AAC3C;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,qDAAqD,OAAO;AAC5D;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,sCAAsC,WAAW;AACjD,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,OAAO;AAChE;AACA;AACA;AACA,0CAA0C,WAAW;AACrD,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA,iEAAe,MAAM;;;;;;;;;;;;;;;ACpRrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE;AACjE;AACA;AACA;AACA;AACA,sCAAsC;AACtC,4CAA4C;AAC5C;AACA;AACA,SAAS;AACT;AACA,+BAA+B;AAC/B,gDAAgD;AAChD,SAAS;AACT;AACA;AACA;AACA;AACA,qCAAqC;AACrC,mDAAmD;AACnD;AACA;AACA,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD;AACtD,qCAAqC;AACrC;AACA,0EAA0E;AAC1E,wCAAwC;AACxC,sCAAsC;AACtC;AACA,uCAAuC;AACvC;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,iEAAe,IAAI;;;;;;;;;;;;;;;ACzDnB;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD;AACnD;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B,oCAAoC;AACpC,uBAAuB,IAAI,GAAG;AAC9B,UAAU;AACV,wBAAwB;AACxB;AACA;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA,2DAA2D;AAC3D;AACA,uBAAuB;AACvB;AACA,iCAAiC;AACjC,iDAAiD;AACjD;AACA,8CAA8C;AAC9C,gDAAgD;AAChD,oDAAoD;AACpD,oDAAoD;AACpD;AACA,gCAAgC;AAChC,6CAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe,KAAK;;;;;;;;;;;;;;;AC5DpB,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA,SAAS;AACT;AACA,KAAK,GAAG;AACR;AACA,6BAA6B;AAC7B;AACA;;;;;;;UCdA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCtBA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA;;;;;WCPA;WACA;WACA;WACA;WACA,GAAG;WACH;WACA;WACA,CAAC;;;;;WCPD;;;;;WCAA;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D;;;;;;;;;;;;;;;;;;;ACNa;AACb;AACA,0GAA+B;AAC/B;AACkC;AACA;AACE;AACA;AACA;AACE;AACF;AACI;AACxC;AACA,oDAAoD;AACpD;AACA,0CAA0C,0DAAS,kCAAkC;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,yDAAI;AACR,IAAI,yDAAI;AACR,IAAI,0DAAK;AACT,IAAI,0DAAK;AACT,IAAI,0DAAK;AACT,IAAI,2DAAM;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,IAAI,0DAAK;AACT;AACA,CAAC,E","sources":["webpack://food/../../../node_modules/es6-promise/dist/es6-promise.js","webpack://food/./js/modules/calc.js","webpack://food/./js/modules/cards.js","webpack://food/./js/modules/forms.js","webpack://food/./js/modules/modal.js","webpack://food/./js/modules/slider.js","webpack://food/./js/modules/tabs.js","webpack://food/./js/modules/timer.js","webpack://food/./js/services/services.js","webpack://food/webpack/bootstrap","webpack://food/webpack/runtime/define property getters","webpack://food/webpack/runtime/global","webpack://food/webpack/runtime/hasOwnProperty shorthand","webpack://food/webpack/runtime/make namespace object","webpack://food/./js/main.js"],"sourcesContent":["/*!\n * @overview es6-promise - a tiny implementation of Promises/A+.\n * @copyright Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and contributors (Conversion to ES6 API by Jake Archibald)\n * @license   Licensed under MIT license\n *            See https://raw.githubusercontent.com/stefanpenner/es6-promise/master/LICENSE\n * @version   v4.2.8+1e68dce6\n */\n\n(function (global, factory) {\n\ttypeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n\ttypeof define === 'function' && define.amd ? define(factory) :\n\t(global.ES6Promise = factory());\n}(this, (function () { 'use strict';\n\nfunction objectOrFunction(x) {\n  var type = typeof x;\n  return x !== null && (type === 'object' || type === 'function');\n}\n\nfunction isFunction(x) {\n  return typeof x === 'function';\n}\n\n\n\nvar _isArray = void 0;\nif (Array.isArray) {\n  _isArray = Array.isArray;\n} else {\n  _isArray = function (x) {\n    return Object.prototype.toString.call(x) === '[object Array]';\n  };\n}\n\nvar isArray = _isArray;\n\nvar len = 0;\nvar vertxNext = void 0;\nvar customSchedulerFn = void 0;\n\nvar asap = function asap(callback, arg) {\n  queue[len] = callback;\n  queue[len + 1] = arg;\n  len += 2;\n  if (len === 2) {\n    // If len is 2, that means that we need to schedule an async flush.\n    // If additional callbacks are queued before the queue is flushed, they\n    // will be processed by this flush that we are scheduling.\n    if (customSchedulerFn) {\n      customSchedulerFn(flush);\n    } else {\n      scheduleFlush();\n    }\n  }\n};\n\nfunction setScheduler(scheduleFn) {\n  customSchedulerFn = scheduleFn;\n}\n\nfunction setAsap(asapFn) {\n  asap = asapFn;\n}\n\nvar browserWindow = typeof window !== 'undefined' ? window : undefined;\nvar browserGlobal = browserWindow || {};\nvar BrowserMutationObserver = browserGlobal.MutationObserver || browserGlobal.WebKitMutationObserver;\nvar isNode = typeof self === 'undefined' && typeof process !== 'undefined' && {}.toString.call(process) === '[object process]';\n\n// test for web worker but not in IE10\nvar isWorker = typeof Uint8ClampedArray !== 'undefined' && typeof importScripts !== 'undefined' && typeof MessageChannel !== 'undefined';\n\n// node\nfunction useNextTick() {\n  // node version 0.10.x displays a deprecation warning when nextTick is used recursively\n  // see https://github.com/cujojs/when/issues/410 for details\n  return function () {\n    return process.nextTick(flush);\n  };\n}\n\n// vertx\nfunction useVertxTimer() {\n  if (typeof vertxNext !== 'undefined') {\n    return function () {\n      vertxNext(flush);\n    };\n  }\n\n  return useSetTimeout();\n}\n\nfunction useMutationObserver() {\n  var iterations = 0;\n  var observer = new BrowserMutationObserver(flush);\n  var node = document.createTextNode('');\n  observer.observe(node, { characterData: true });\n\n  return function () {\n    node.data = iterations = ++iterations % 2;\n  };\n}\n\n// web worker\nfunction useMessageChannel() {\n  var channel = new MessageChannel();\n  channel.port1.onmessage = flush;\n  return function () {\n    return channel.port2.postMessage(0);\n  };\n}\n\nfunction useSetTimeout() {\n  // Store setTimeout reference so es6-promise will be unaffected by\n  // other code modifying setTimeout (like sinon.useFakeTimers())\n  var globalSetTimeout = setTimeout;\n  return function () {\n    return globalSetTimeout(flush, 1);\n  };\n}\n\nvar queue = new Array(1000);\nfunction flush() {\n  for (var i = 0; i < len; i += 2) {\n    var callback = queue[i];\n    var arg = queue[i + 1];\n\n    callback(arg);\n\n    queue[i] = undefined;\n    queue[i + 1] = undefined;\n  }\n\n  len = 0;\n}\n\nfunction attemptVertx() {\n  try {\n    var vertx = Function('return this')().require('vertx');\n    vertxNext = vertx.runOnLoop || vertx.runOnContext;\n    return useVertxTimer();\n  } catch (e) {\n    return useSetTimeout();\n  }\n}\n\nvar scheduleFlush = void 0;\n// Decide what async method to use to triggering processing of queued callbacks:\nif (isNode) {\n  scheduleFlush = useNextTick();\n} else if (BrowserMutationObserver) {\n  scheduleFlush = useMutationObserver();\n} else if (isWorker) {\n  scheduleFlush = useMessageChannel();\n} else if (browserWindow === undefined && typeof require === 'function') {\n  scheduleFlush = attemptVertx();\n} else {\n  scheduleFlush = useSetTimeout();\n}\n\nfunction then(onFulfillment, onRejection) {\n  var parent = this;\n\n  var child = new this.constructor(noop);\n\n  if (child[PROMISE_ID] === undefined) {\n    makePromise(child);\n  }\n\n  var _state = parent._state;\n\n\n  if (_state) {\n    var callback = arguments[_state - 1];\n    asap(function () {\n      return invokeCallback(_state, child, callback, parent._result);\n    });\n  } else {\n    subscribe(parent, child, onFulfillment, onRejection);\n  }\n\n  return child;\n}\n\n/**\n  `Promise.resolve` returns a promise that will become resolved with the\n  passed `value`. It is shorthand for the following:\n\n  ```javascript\n  let promise = new Promise(function(resolve, reject){\n    resolve(1);\n  });\n\n  promise.then(function(value){\n    // value === 1\n  });\n  ```\n\n  Instead of writing the above, your code now simply becomes the following:\n\n  ```javascript\n  let promise = Promise.resolve(1);\n\n  promise.then(function(value){\n    // value === 1\n  });\n  ```\n\n  @method resolve\n  @static\n  @param {Any} value value that the returned promise will be resolved with\n  Useful for tooling.\n  @return {Promise} a promise that will become fulfilled with the given\n  `value`\n*/\nfunction resolve$1(object) {\n  /*jshint validthis:true */\n  var Constructor = this;\n\n  if (object && typeof object === 'object' && object.constructor === Constructor) {\n    return object;\n  }\n\n  var promise = new Constructor(noop);\n  resolve(promise, object);\n  return promise;\n}\n\nvar PROMISE_ID = Math.random().toString(36).substring(2);\n\nfunction noop() {}\n\nvar PENDING = void 0;\nvar FULFILLED = 1;\nvar REJECTED = 2;\n\nfunction selfFulfillment() {\n  return new TypeError(\"You cannot resolve a promise with itself\");\n}\n\nfunction cannotReturnOwn() {\n  return new TypeError('A promises callback cannot return that same promise.');\n}\n\nfunction tryThen(then$$1, value, fulfillmentHandler, rejectionHandler) {\n  try {\n    then$$1.call(value, fulfillmentHandler, rejectionHandler);\n  } catch (e) {\n    return e;\n  }\n}\n\nfunction handleForeignThenable(promise, thenable, then$$1) {\n  asap(function (promise) {\n    var sealed = false;\n    var error = tryThen(then$$1, thenable, function (value) {\n      if (sealed) {\n        return;\n      }\n      sealed = true;\n      if (thenable !== value) {\n        resolve(promise, value);\n      } else {\n        fulfill(promise, value);\n      }\n    }, function (reason) {\n      if (sealed) {\n        return;\n      }\n      sealed = true;\n\n      reject(promise, reason);\n    }, 'Settle: ' + (promise._label || ' unknown promise'));\n\n    if (!sealed && error) {\n      sealed = true;\n      reject(promise, error);\n    }\n  }, promise);\n}\n\nfunction handleOwnThenable(promise, thenable) {\n  if (thenable._state === FULFILLED) {\n    fulfill(promise, thenable._result);\n  } else if (thenable._state === REJECTED) {\n    reject(promise, thenable._result);\n  } else {\n    subscribe(thenable, undefined, function (value) {\n      return resolve(promise, value);\n    }, function (reason) {\n      return reject(promise, reason);\n    });\n  }\n}\n\nfunction handleMaybeThenable(promise, maybeThenable, then$$1) {\n  if (maybeThenable.constructor === promise.constructor && then$$1 === then && maybeThenable.constructor.resolve === resolve$1) {\n    handleOwnThenable(promise, maybeThenable);\n  } else {\n    if (then$$1 === undefined) {\n      fulfill(promise, maybeThenable);\n    } else if (isFunction(then$$1)) {\n      handleForeignThenable(promise, maybeThenable, then$$1);\n    } else {\n      fulfill(promise, maybeThenable);\n    }\n  }\n}\n\nfunction resolve(promise, value) {\n  if (promise === value) {\n    reject(promise, selfFulfillment());\n  } else if (objectOrFunction(value)) {\n    var then$$1 = void 0;\n    try {\n      then$$1 = value.then;\n    } catch (error) {\n      reject(promise, error);\n      return;\n    }\n    handleMaybeThenable(promise, value, then$$1);\n  } else {\n    fulfill(promise, value);\n  }\n}\n\nfunction publishRejection(promise) {\n  if (promise._onerror) {\n    promise._onerror(promise._result);\n  }\n\n  publish(promise);\n}\n\nfunction fulfill(promise, value) {\n  if (promise._state !== PENDING) {\n    return;\n  }\n\n  promise._result = value;\n  promise._state = FULFILLED;\n\n  if (promise._subscribers.length !== 0) {\n    asap(publish, promise);\n  }\n}\n\nfunction reject(promise, reason) {\n  if (promise._state !== PENDING) {\n    return;\n  }\n  promise._state = REJECTED;\n  promise._result = reason;\n\n  asap(publishRejection, promise);\n}\n\nfunction subscribe(parent, child, onFulfillment, onRejection) {\n  var _subscribers = parent._subscribers;\n  var length = _subscribers.length;\n\n\n  parent._onerror = null;\n\n  _subscribers[length] = child;\n  _subscribers[length + FULFILLED] = onFulfillment;\n  _subscribers[length + REJECTED] = onRejection;\n\n  if (length === 0 && parent._state) {\n    asap(publish, parent);\n  }\n}\n\nfunction publish(promise) {\n  var subscribers = promise._subscribers;\n  var settled = promise._state;\n\n  if (subscribers.length === 0) {\n    return;\n  }\n\n  var child = void 0,\n      callback = void 0,\n      detail = promise._result;\n\n  for (var i = 0; i < subscribers.length; i += 3) {\n    child = subscribers[i];\n    callback = subscribers[i + settled];\n\n    if (child) {\n      invokeCallback(settled, child, callback, detail);\n    } else {\n      callback(detail);\n    }\n  }\n\n  promise._subscribers.length = 0;\n}\n\nfunction invokeCallback(settled, promise, callback, detail) {\n  var hasCallback = isFunction(callback),\n      value = void 0,\n      error = void 0,\n      succeeded = true;\n\n  if (hasCallback) {\n    try {\n      value = callback(detail);\n    } catch (e) {\n      succeeded = false;\n      error = e;\n    }\n\n    if (promise === value) {\n      reject(promise, cannotReturnOwn());\n      return;\n    }\n  } else {\n    value = detail;\n  }\n\n  if (promise._state !== PENDING) {\n    // noop\n  } else if (hasCallback && succeeded) {\n    resolve(promise, value);\n  } else if (succeeded === false) {\n    reject(promise, error);\n  } else if (settled === FULFILLED) {\n    fulfill(promise, value);\n  } else if (settled === REJECTED) {\n    reject(promise, value);\n  }\n}\n\nfunction initializePromise(promise, resolver) {\n  try {\n    resolver(function resolvePromise(value) {\n      resolve(promise, value);\n    }, function rejectPromise(reason) {\n      reject(promise, reason);\n    });\n  } catch (e) {\n    reject(promise, e);\n  }\n}\n\nvar id = 0;\nfunction nextId() {\n  return id++;\n}\n\nfunction makePromise(promise) {\n  promise[PROMISE_ID] = id++;\n  promise._state = undefined;\n  promise._result = undefined;\n  promise._subscribers = [];\n}\n\nfunction validationError() {\n  return new Error('Array Methods must be provided an Array');\n}\n\nvar Enumerator = function () {\n  function Enumerator(Constructor, input) {\n    this._instanceConstructor = Constructor;\n    this.promise = new Constructor(noop);\n\n    if (!this.promise[PROMISE_ID]) {\n      makePromise(this.promise);\n    }\n\n    if (isArray(input)) {\n      this.length = input.length;\n      this._remaining = input.length;\n\n      this._result = new Array(this.length);\n\n      if (this.length === 0) {\n        fulfill(this.promise, this._result);\n      } else {\n        this.length = this.length || 0;\n        this._enumerate(input);\n        if (this._remaining === 0) {\n          fulfill(this.promise, this._result);\n        }\n      }\n    } else {\n      reject(this.promise, validationError());\n    }\n  }\n\n  Enumerator.prototype._enumerate = function _enumerate(input) {\n    for (var i = 0; this._state === PENDING && i < input.length; i++) {\n      this._eachEntry(input[i], i);\n    }\n  };\n\n  Enumerator.prototype._eachEntry = function _eachEntry(entry, i) {\n    var c = this._instanceConstructor;\n    var resolve$$1 = c.resolve;\n\n\n    if (resolve$$1 === resolve$1) {\n      var _then = void 0;\n      var error = void 0;\n      var didError = false;\n      try {\n        _then = entry.then;\n      } catch (e) {\n        didError = true;\n        error = e;\n      }\n\n      if (_then === then && entry._state !== PENDING) {\n        this._settledAt(entry._state, i, entry._result);\n      } else if (typeof _then !== 'function') {\n        this._remaining--;\n        this._result[i] = entry;\n      } else if (c === Promise$1) {\n        var promise = new c(noop);\n        if (didError) {\n          reject(promise, error);\n        } else {\n          handleMaybeThenable(promise, entry, _then);\n        }\n        this._willSettleAt(promise, i);\n      } else {\n        this._willSettleAt(new c(function (resolve$$1) {\n          return resolve$$1(entry);\n        }), i);\n      }\n    } else {\n      this._willSettleAt(resolve$$1(entry), i);\n    }\n  };\n\n  Enumerator.prototype._settledAt = function _settledAt(state, i, value) {\n    var promise = this.promise;\n\n\n    if (promise._state === PENDING) {\n      this._remaining--;\n\n      if (state === REJECTED) {\n        reject(promise, value);\n      } else {\n        this._result[i] = value;\n      }\n    }\n\n    if (this._remaining === 0) {\n      fulfill(promise, this._result);\n    }\n  };\n\n  Enumerator.prototype._willSettleAt = function _willSettleAt(promise, i) {\n    var enumerator = this;\n\n    subscribe(promise, undefined, function (value) {\n      return enumerator._settledAt(FULFILLED, i, value);\n    }, function (reason) {\n      return enumerator._settledAt(REJECTED, i, reason);\n    });\n  };\n\n  return Enumerator;\n}();\n\n/**\n  `Promise.all` accepts an array of promises, and returns a new promise which\n  is fulfilled with an array of fulfillment values for the passed promises, or\n  rejected with the reason of the first passed promise to be rejected. It casts all\n  elements of the passed iterable to promises as it runs this algorithm.\n\n  Example:\n\n  ```javascript\n  let promise1 = resolve(1);\n  let promise2 = resolve(2);\n  let promise3 = resolve(3);\n  let promises = [ promise1, promise2, promise3 ];\n\n  Promise.all(promises).then(function(array){\n    // The array here would be [ 1, 2, 3 ];\n  });\n  ```\n\n  If any of the `promises` given to `all` are rejected, the first promise\n  that is rejected will be given as an argument to the returned promises's\n  rejection handler. For example:\n\n  Example:\n\n  ```javascript\n  let promise1 = resolve(1);\n  let promise2 = reject(new Error(\"2\"));\n  let promise3 = reject(new Error(\"3\"));\n  let promises = [ promise1, promise2, promise3 ];\n\n  Promise.all(promises).then(function(array){\n    // Code here never runs because there are rejected promises!\n  }, function(error) {\n    // error.message === \"2\"\n  });\n  ```\n\n  @method all\n  @static\n  @param {Array} entries array of promises\n  @param {String} label optional string for labeling the promise.\n  Useful for tooling.\n  @return {Promise} promise that is fulfilled when all `promises` have been\n  fulfilled, or rejected if any of them become rejected.\n  @static\n*/\nfunction all(entries) {\n  return new Enumerator(this, entries).promise;\n}\n\n/**\n  `Promise.race` returns a new promise which is settled in the same way as the\n  first passed promise to settle.\n\n  Example:\n\n  ```javascript\n  let promise1 = new Promise(function(resolve, reject){\n    setTimeout(function(){\n      resolve('promise 1');\n    }, 200);\n  });\n\n  let promise2 = new Promise(function(resolve, reject){\n    setTimeout(function(){\n      resolve('promise 2');\n    }, 100);\n  });\n\n  Promise.race([promise1, promise2]).then(function(result){\n    // result === 'promise 2' because it was resolved before promise1\n    // was resolved.\n  });\n  ```\n\n  `Promise.race` is deterministic in that only the state of the first\n  settled promise matters. For example, even if other promises given to the\n  `promises` array argument are resolved, but the first settled promise has\n  become rejected before the other promises became fulfilled, the returned\n  promise will become rejected:\n\n  ```javascript\n  let promise1 = new Promise(function(resolve, reject){\n    setTimeout(function(){\n      resolve('promise 1');\n    }, 200);\n  });\n\n  let promise2 = new Promise(function(resolve, reject){\n    setTimeout(function(){\n      reject(new Error('promise 2'));\n    }, 100);\n  });\n\n  Promise.race([promise1, promise2]).then(function(result){\n    // Code here never runs\n  }, function(reason){\n    // reason.message === 'promise 2' because promise 2 became rejected before\n    // promise 1 became fulfilled\n  });\n  ```\n\n  An example real-world use case is implementing timeouts:\n\n  ```javascript\n  Promise.race([ajax('foo.json'), timeout(5000)])\n  ```\n\n  @method race\n  @static\n  @param {Array} promises array of promises to observe\n  Useful for tooling.\n  @return {Promise} a promise which settles in the same way as the first passed\n  promise to settle.\n*/\nfunction race(entries) {\n  /*jshint validthis:true */\n  var Constructor = this;\n\n  if (!isArray(entries)) {\n    return new Constructor(function (_, reject) {\n      return reject(new TypeError('You must pass an array to race.'));\n    });\n  } else {\n    return new Constructor(function (resolve, reject) {\n      var length = entries.length;\n      for (var i = 0; i < length; i++) {\n        Constructor.resolve(entries[i]).then(resolve, reject);\n      }\n    });\n  }\n}\n\n/**\n  `Promise.reject` returns a promise rejected with the passed `reason`.\n  It is shorthand for the following:\n\n  ```javascript\n  let promise = new Promise(function(resolve, reject){\n    reject(new Error('WHOOPS'));\n  });\n\n  promise.then(function(value){\n    // Code here doesn't run because the promise is rejected!\n  }, function(reason){\n    // reason.message === 'WHOOPS'\n  });\n  ```\n\n  Instead of writing the above, your code now simply becomes the following:\n\n  ```javascript\n  let promise = Promise.reject(new Error('WHOOPS'));\n\n  promise.then(function(value){\n    // Code here doesn't run because the promise is rejected!\n  }, function(reason){\n    // reason.message === 'WHOOPS'\n  });\n  ```\n\n  @method reject\n  @static\n  @param {Any} reason value that the returned promise will be rejected with.\n  Useful for tooling.\n  @return {Promise} a promise rejected with the given `reason`.\n*/\nfunction reject$1(reason) {\n  /*jshint validthis:true */\n  var Constructor = this;\n  var promise = new Constructor(noop);\n  reject(promise, reason);\n  return promise;\n}\n\nfunction needsResolver() {\n  throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');\n}\n\nfunction needsNew() {\n  throw new TypeError(\"Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.\");\n}\n\n/**\n  Promise objects represent the eventual result of an asynchronous operation. The\n  primary way of interacting with a promise is through its `then` method, which\n  registers callbacks to receive either a promise's eventual value or the reason\n  why the promise cannot be fulfilled.\n\n  Terminology\n  -----------\n\n  - `promise` is an object or function with a `then` method whose behavior conforms to this specification.\n  - `thenable` is an object or function that defines a `then` method.\n  - `value` is any legal JavaScript value (including undefined, a thenable, or a promise).\n  - `exception` is a value that is thrown using the throw statement.\n  - `reason` is a value that indicates why a promise was rejected.\n  - `settled` the final resting state of a promise, fulfilled or rejected.\n\n  A promise can be in one of three states: pending, fulfilled, or rejected.\n\n  Promises that are fulfilled have a fulfillment value and are in the fulfilled\n  state.  Promises that are rejected have a rejection reason and are in the\n  rejected state.  A fulfillment value is never a thenable.\n\n  Promises can also be said to *resolve* a value.  If this value is also a\n  promise, then the original promise's settled state will match the value's\n  settled state.  So a promise that *resolves* a promise that rejects will\n  itself reject, and a promise that *resolves* a promise that fulfills will\n  itself fulfill.\n\n\n  Basic Usage:\n  ------------\n\n  ```js\n  let promise = new Promise(function(resolve, reject) {\n    // on success\n    resolve(value);\n\n    // on failure\n    reject(reason);\n  });\n\n  promise.then(function(value) {\n    // on fulfillment\n  }, function(reason) {\n    // on rejection\n  });\n  ```\n\n  Advanced Usage:\n  ---------------\n\n  Promises shine when abstracting away asynchronous interactions such as\n  `XMLHttpRequest`s.\n\n  ```js\n  function getJSON(url) {\n    return new Promise(function(resolve, reject){\n      let xhr = new XMLHttpRequest();\n\n      xhr.open('GET', url);\n      xhr.onreadystatechange = handler;\n      xhr.responseType = 'json';\n      xhr.setRequestHeader('Accept', 'application/json');\n      xhr.send();\n\n      function handler() {\n        if (this.readyState === this.DONE) {\n          if (this.status === 200) {\n            resolve(this.response);\n          } else {\n            reject(new Error('getJSON: `' + url + '` failed with status: [' + this.status + ']'));\n          }\n        }\n      };\n    });\n  }\n\n  getJSON('/posts.json').then(function(json) {\n    // on fulfillment\n  }, function(reason) {\n    // on rejection\n  });\n  ```\n\n  Unlike callbacks, promises are great composable primitives.\n\n  ```js\n  Promise.all([\n    getJSON('/posts'),\n    getJSON('/comments')\n  ]).then(function(values){\n    values[0] // => postsJSON\n    values[1] // => commentsJSON\n\n    return values;\n  });\n  ```\n\n  @class Promise\n  @param {Function} resolver\n  Useful for tooling.\n  @constructor\n*/\n\nvar Promise$1 = function () {\n  function Promise(resolver) {\n    this[PROMISE_ID] = nextId();\n    this._result = this._state = undefined;\n    this._subscribers = [];\n\n    if (noop !== resolver) {\n      typeof resolver !== 'function' && needsResolver();\n      this instanceof Promise ? initializePromise(this, resolver) : needsNew();\n    }\n  }\n\n  /**\n  The primary way of interacting with a promise is through its `then` method,\n  which registers callbacks to receive either a promise's eventual value or the\n  reason why the promise cannot be fulfilled.\n   ```js\n  findUser().then(function(user){\n    // user is available\n  }, function(reason){\n    // user is unavailable, and you are given the reason why\n  });\n  ```\n   Chaining\n  --------\n   The return value of `then` is itself a promise.  This second, 'downstream'\n  promise is resolved with the return value of the first promise's fulfillment\n  or rejection handler, or rejected if the handler throws an exception.\n   ```js\n  findUser().then(function (user) {\n    return user.name;\n  }, function (reason) {\n    return 'default name';\n  }).then(function (userName) {\n    // If `findUser` fulfilled, `userName` will be the user's name, otherwise it\n    // will be `'default name'`\n  });\n   findUser().then(function (user) {\n    throw new Error('Found user, but still unhappy');\n  }, function (reason) {\n    throw new Error('`findUser` rejected and we're unhappy');\n  }).then(function (value) {\n    // never reached\n  }, function (reason) {\n    // if `findUser` fulfilled, `reason` will be 'Found user, but still unhappy'.\n    // If `findUser` rejected, `reason` will be '`findUser` rejected and we're unhappy'.\n  });\n  ```\n  If the downstream promise does not specify a rejection handler, rejection reasons will be propagated further downstream.\n   ```js\n  findUser().then(function (user) {\n    throw new PedagogicalException('Upstream error');\n  }).then(function (value) {\n    // never reached\n  }).then(function (value) {\n    // never reached\n  }, function (reason) {\n    // The `PedgagocialException` is propagated all the way down to here\n  });\n  ```\n   Assimilation\n  ------------\n   Sometimes the value you want to propagate to a downstream promise can only be\n  retrieved asynchronously. This can be achieved by returning a promise in the\n  fulfillment or rejection handler. The downstream promise will then be pending\n  until the returned promise is settled. This is called *assimilation*.\n   ```js\n  findUser().then(function (user) {\n    return findCommentsByAuthor(user);\n  }).then(function (comments) {\n    // The user's comments are now available\n  });\n  ```\n   If the assimliated promise rejects, then the downstream promise will also reject.\n   ```js\n  findUser().then(function (user) {\n    return findCommentsByAuthor(user);\n  }).then(function (comments) {\n    // If `findCommentsByAuthor` fulfills, we'll have the value here\n  }, function (reason) {\n    // If `findCommentsByAuthor` rejects, we'll have the reason here\n  });\n  ```\n   Simple Example\n  --------------\n   Synchronous Example\n   ```javascript\n  let result;\n   try {\n    result = findResult();\n    // success\n  } catch(reason) {\n    // failure\n  }\n  ```\n   Errback Example\n   ```js\n  findResult(function(result, err){\n    if (err) {\n      // failure\n    } else {\n      // success\n    }\n  });\n  ```\n   Promise Example;\n   ```javascript\n  findResult().then(function(result){\n    // success\n  }, function(reason){\n    // failure\n  });\n  ```\n   Advanced Example\n  --------------\n   Synchronous Example\n   ```javascript\n  let author, books;\n   try {\n    author = findAuthor();\n    books  = findBooksByAuthor(author);\n    // success\n  } catch(reason) {\n    // failure\n  }\n  ```\n   Errback Example\n   ```js\n   function foundBooks(books) {\n   }\n   function failure(reason) {\n   }\n   findAuthor(function(author, err){\n    if (err) {\n      failure(err);\n      // failure\n    } else {\n      try {\n        findBoooksByAuthor(author, function(books, err) {\n          if (err) {\n            failure(err);\n          } else {\n            try {\n              foundBooks(books);\n            } catch(reason) {\n              failure(reason);\n            }\n          }\n        });\n      } catch(error) {\n        failure(err);\n      }\n      // success\n    }\n  });\n  ```\n   Promise Example;\n   ```javascript\n  findAuthor().\n    then(findBooksByAuthor).\n    then(function(books){\n      // found books\n  }).catch(function(reason){\n    // something went wrong\n  });\n  ```\n   @method then\n  @param {Function} onFulfilled\n  @param {Function} onRejected\n  Useful for tooling.\n  @return {Promise}\n  */\n\n  /**\n  `catch` is simply sugar for `then(undefined, onRejection)` which makes it the same\n  as the catch block of a try/catch statement.\n  ```js\n  function findAuthor(){\n  throw new Error('couldn't find that author');\n  }\n  // synchronous\n  try {\n  findAuthor();\n  } catch(reason) {\n  // something went wrong\n  }\n  // async with promises\n  findAuthor().catch(function(reason){\n  // something went wrong\n  });\n  ```\n  @method catch\n  @param {Function} onRejection\n  Useful for tooling.\n  @return {Promise}\n  */\n\n\n  Promise.prototype.catch = function _catch(onRejection) {\n    return this.then(null, onRejection);\n  };\n\n  /**\n    `finally` will be invoked regardless of the promise's fate just as native\n    try/catch/finally behaves\n  \n    Synchronous example:\n  \n    ```js\n    findAuthor() {\n      if (Math.random() > 0.5) {\n        throw new Error();\n      }\n      return new Author();\n    }\n  \n    try {\n      return findAuthor(); // succeed or fail\n    } catch(error) {\n      return findOtherAuther();\n    } finally {\n      // always runs\n      // doesn't affect the return value\n    }\n    ```\n  \n    Asynchronous example:\n  \n    ```js\n    findAuthor().catch(function(reason){\n      return findOtherAuther();\n    }).finally(function(){\n      // author was either found, or not\n    });\n    ```\n  \n    @method finally\n    @param {Function} callback\n    @return {Promise}\n  */\n\n\n  Promise.prototype.finally = function _finally(callback) {\n    var promise = this;\n    var constructor = promise.constructor;\n\n    if (isFunction(callback)) {\n      return promise.then(function (value) {\n        return constructor.resolve(callback()).then(function () {\n          return value;\n        });\n      }, function (reason) {\n        return constructor.resolve(callback()).then(function () {\n          throw reason;\n        });\n      });\n    }\n\n    return promise.then(callback, callback);\n  };\n\n  return Promise;\n}();\n\nPromise$1.prototype.then = then;\nPromise$1.all = all;\nPromise$1.race = race;\nPromise$1.resolve = resolve$1;\nPromise$1.reject = reject$1;\nPromise$1._setScheduler = setScheduler;\nPromise$1._setAsap = setAsap;\nPromise$1._asap = asap;\n\n/*global self*/\nfunction polyfill() {\n  var local = void 0;\n\n  if (typeof global !== 'undefined') {\n    local = global;\n  } else if (typeof self !== 'undefined') {\n    local = self;\n  } else {\n    try {\n      local = Function('return this')();\n    } catch (e) {\n      throw new Error('polyfill failed because global object is unavailable in this environment');\n    }\n  }\n\n  var P = local.Promise;\n\n  if (P) {\n    var promiseToString = null;\n    try {\n      promiseToString = Object.prototype.toString.call(P.resolve());\n    } catch (e) {\n      // silently ignored\n    }\n\n    if (promiseToString === '[object Promise]' && !P.cast) {\n      return;\n    }\n  }\n\n  local.Promise = Promise$1;\n}\n\n// Strange compat..\nPromise$1.polyfill = polyfill;\nPromise$1.Promise = Promise$1;\n\nreturn Promise$1;\n\n})));\n\n\n\n//# sourceMappingURL=es6-promise.map\n","function calc() {\r\n    //=== Calc ===\r\n\r\n    const result = document.querySelector('.calculating__result span');\r\n\r\n    let sex, height, weight, age, ratio;\r\n\r\n    if (localStorage.getItem('sex')) {\r\n        sex = localStorage.getItem('sex');\r\n    } else {\r\n        sex = 'female';\r\n        localStorage.setItem('sex', 'female');\r\n    }\r\n\r\n    if (localStorage.getItem('ratio')) {\r\n        ratio = localStorage.getItem('ratio');\r\n    } else {\r\n        ratio = 1.375;\r\n        localStorage.setItem('ratio', 1.375);\r\n    }\r\n\r\n\r\n    function initlocalSettings(selector, activeClass) {\r\n        const elements = document.querySelectorAll(selector);\r\n\r\n        elements.forEach(elem => {\r\n            elem.classList.remove(activeClass);\r\n            if (elem.getAttribute('id') === localStorage.getItem('sex')) {\r\n                elem.classList.add(activeClass);\r\n            }\r\n            if (elem.getAttribute('data-ratio') === localStorage.getItem('ratio')) {\r\n                elem.classList.add(activeClass);\r\n            }\r\n        });\r\n    }\r\n\r\n    initlocalSettings('#gender div', 'calculating__choose-item_active');\r\n    initlocalSettings('.calculating__choose_big div', 'calculating__choose-item_active');\r\n\r\n    function calcTotal() { //будет выполнятся каждый раз при изменении какого либо параметра\r\n        //делаем проверку заплнены ли все данные, если хоть что-то не заполнено, то подсчеты не делаются\r\n        if (!sex || !height || !weight || !age || !ratio) {\r\n            result.textContent = '____';\r\n            // если хоть какй то параметр отсутствует, вставляем текст 4псевдопробела\r\n            return; //и прирываем функцию\r\n        }\r\n\r\n        //считаем коллории для женщин\r\n        if (sex === 'female') {\r\n            result.textContent = Math.round((447.6 + (9.2 * weight) + (3.1 * height) - (4.3 * age)) * ratio);\r\n        } else {\r\n            result.textContent = Math.round((88.36 + (13.4 * weight) + (4.8 * height) - (5.7 * age)) * ratio);\r\n        }\r\n\r\n    }\r\n\r\n    calcTotal();\r\n\r\n    function getStaticInformation(selector, activeClass) {\r\n        //получаем информацию со статичных блоков\r\n        const elements = document.querySelectorAll(selector);\r\n        //получаю все дивы внутри введенного родителя\r\n\r\n        elements.forEach(elem => {\r\n            elem.addEventListener('click', (e) => {\r\n                //если объект события содержит атрибут data-ratio, то изменяем ratio, иначе получаем id\r\n                if (e.target.getAttribute('data-ratio')) {\r\n                    ratio = +e.target.getAttribute('data-ratio');\r\n                    localStorage.setItem('ratio', +e.target.getAttribute('data-ratio'));\r\n                } else {\r\n                    sex = e.target.getAttribute('id');\r\n                    localStorage.setItem('sex', e.target.getAttribute('id'));\r\n                }\r\n\r\n                //сбрасываем класс активности у элементов и задем тот. на который кликнули\r\n                elements.forEach(elem => {\r\n                    elem.classList.remove(activeClass);\r\n                });\r\n\r\n                e.target.classList.add(activeClass);\r\n\r\n                calcTotal();\r\n            });\r\n        });\r\n\r\n    }\r\n\r\n    getStaticInformation('#gender div', 'calculating__choose-item_active');\r\n    getStaticInformation('.calculating__choose_big div', 'calculating__choose-item_active');\r\n\r\n    function getDynamicInformation(selector) {\r\n        const input = document.querySelector(selector);\r\n\r\n        input.addEventListener('input', () => {\r\n            if (input.value.match(/\\D/g)) {\r\n                input.style.border = '1px solid red';\r\n            } else {\r\n                input.style.border = 'none';\r\n            }\r\n\r\n            switch (input.getAttribute('id')) {\r\n                case 'height':\r\n                    height = +input.value;\r\n                    break;\r\n                case 'weight':\r\n                    weight = +input.value;\r\n                    break;\r\n                case 'age':\r\n                    age = +input.value;\r\n                    break;\r\n            }\r\n\r\n            calcTotal();\r\n        });\r\n\r\n\r\n    }\r\n\r\n    getDynamicInformation('#height');\r\n    getDynamicInformation('#weight');\r\n    getDynamicInformation('#age');\r\n}\r\n\r\n// module.exports = calc;\r\nexport default calc;","function cards() {\r\n    //--- Карточки рецептов ---\r\n\r\n    //--- мое решение -- создание класса для карточки меню ---\r\n\r\n    // const menuItem = document.querySelector('.menu__field .container');\r\n\r\n    // class MenuItemCard {\r\n    //     constructor(src, title, description, cost, alt) {\r\n    //         this.src = src;\r\n    //         this.alt = alt;\r\n    //         this.title = title;\r\n    //         this.description = description;\r\n    //         this.cost = cost;\r\n    //     }\r\n\r\n    //     addedImage() {\r\n    //         menuItem.insertAdjacentHTML('beforeend', `<div class=\"menu__item\"> <img src=\"${this.src}\" alt=\"${this.src}\"><h3 class=\"menu__item-subtitle\">${this.title}</h3> <div class=\"menu__item-descr\">${this.description}</div> <div class=\"menu__item-divider\"></div> <div class=\"menu__item-price\"> <div class=\"menu__item-cost\">Цена:</div> <div class=\"menu__item-total\"><span>${this.cost}</span> грн/день</div> </div> </div>`);\r\n    //     }\r\n    // }\r\n\r\n    // const itemFirst = new MenuItemCard('img/tabs/vegy.jpg', 'Меню \"Фитнес\"', 'Меню \"Фитнес\" - это новый подход к приготовлению блюд: больше свежих овощей и фруктов. Продукт активных и здоровых людей. Это абсолютно новый продукт с оптимальной ценой и высоким качеством!', '229', 'vegy');\r\n    // const secondFirst = new MenuItemCard('img/tabs/post.jpg', 'Меню \"Фитнес 2\"', 'Меню \"Фитнес\" - это новый подход к приготовлению блюд: больше свежих овощей и фруктов. Продукт активных и здоровых людей. Это абсолютно новый продукт с оптимальной ценой и высоким качеством!', '229', 'vegy');\r\n    // const nextFirst = new MenuItemCard('img/tabs/elite.jpg', 'Меню \"Фитнес 3\"', 'Меню \"Фитнес\" - это новый подход к приготовлению блюд: больше свежих овощей и фруктов. Продукт активных и здоровых людей. Это абсолютно новый продукт с оптимальной ценой и высоким качеством!', '229', 'vegy');\r\n\r\n    // itemFirst.addedImage();\r\n    // secondFirst.addedImage();\r\n    // nextFirst.addedImage();\r\n\r\n    //--- Решение преподаваиеля ---\r\n\r\n    // class MenuCard { //создаем новый класс, название класса с большой буквы\r\n    //     constructor(src, alt, title, descr, price, parentSelector) { //вызываем конструктор с аргументами \r\n    //         this.src = src;\r\n    //         this.alt = alt;\r\n    //         this.title = title;\r\n    //         this.descr = descr;\r\n    //         this.price = price;\r\n    //         this.parent = document.querySelector(parentSelector);\r\n    //         this.transfer = 27; //создаем свойство с курсом валют, для перевода в гривны\r\n    //         this.changeToUAH(); //методы можно вызывать прямо внутри конструктора, чтобы он вывел нам итоговую сумму в гривнах\r\n    //     }\r\n\r\n    //     changeToUAH() { //создаем метод для конвертации валют в гривны\r\n    //         this.price = this.price * this.transfer;\r\n\r\n    //     }\r\n\r\n    //     render() { //метод для создания верстки\r\n    //         const element = document.createElement('div'); //создаем элемент, пока он существуект только в скриптах\r\n    //         // вставляем в наш див нашу html структуру\r\n    //         element.innerHTML = `\r\n    //             <div class=\"menu__item\">\r\n    //                 <img src=\"${this.src}\" alt=\"${this.alt}\">\r\n    //                 <h3 class=\"menu__item-subtitle\">${this.title}</h3>\r\n    //                 <div class=\"menu__item-descr\">\r\n    //                     ${this.descr}\r\n    //                 </div>\r\n    //                 <div class=\"menu__item-divider\"></div>\r\n    //                 <div class=\"menu__item-price\">\r\n    //                     <div class=\"menu__item-cost\">Цена:</div>\r\n    //                     <div class=\"menu__item-total\"><span>${this.price}</span> грн/день</div>\r\n    //                 </div>\r\n    //             </div>\r\n    //         `;\r\n\r\n    //         this.parent.append(element); //говорим что в нашего родителя добавили наш элемент\r\n\r\n    //     }\r\n\r\n    // }\r\n\r\n    // const div1 = new MenuCard(\r\n    //     'img/tabs/vegy.jpg', \r\n    //     'vegy',\r\n    //     'Меню \"Фитнес\"', \r\n    //     'Меню \"Фитнес\" - это новый подход к приготовлению блюд: больше свежих овощей и фруктов. Продукт активных и здоровых людей. Это абсолютно новый продукт с оптимальной ценой и высоким качеством!', \r\n    //     9,\r\n    //     '.menu .container');\r\n\r\n    // const div2 = new MenuCard(\r\n    //     'img/tabs/elite.jpg', \r\n    //     'elite',\r\n    //     'Меню “Премиум”', \r\n    //     'В меню “Премиум” мы используем не только красивый дизайн упаковки, но и качественное исполнение блюд. Красная рыба, морепродукты, фрукты - ресторанное меню без похода в ресторан!', \r\n    //     9,\r\n    //     '.menu .container');\r\n\r\n    // const div3 = new MenuCard(\r\n    //     'img/tabs/post.jpg', \r\n    //     'post',\r\n    //     'Меню \"Постное\"', \r\n    //     'Меню “Постное” - это тщательный подбор ингредиентов: полное отсутствие продуктов животного происхождения, молоко из миндаля, овса, кокоса или гречки, правильное количество белков за счет тофу и импортных вегетарианских стейков.', \r\n    //     9,\r\n    //     '.menu .container');\r\n\r\n    // div1.render();\r\n    // div2.render();\r\n    // div3.render();\r\n\r\n    //new MenuCard().render(); -- можно делать такую запись если объект используется только здесь и сейчас\r\n\r\n    //--- REST оператор и параметры по умолчанию\r\n\r\n    // class MenuCard { //создаем новый класс, название класса с большой буквы\r\n    //     constructor(src, alt, title, descr, price, parentSelector, ...classes) { //вызываем конструктор с аргументами, последним аргументом передаем классы для элемента, который добавляем\r\n    //         this.src = src;\r\n    //         this.alt = alt;\r\n    //         this.title = title;\r\n    //         this.descr = descr;\r\n    //         this.price = price;\r\n    //         this.classes = classes; //переадваться будет массив классов из оператора rest\r\n    //         this.parent = document.querySelector(parentSelector);\r\n    //         this.transfer = 27; //создаем свойство с курсом валют, для перевода в гривны\r\n    //         this.changeToUAH(); //методы можно вызывать прямо внутри конструктора, чтобы он вывел нам итоговую сумму в гривнах\r\n    //     }\r\n\r\n    //     changeToUAH() { //создаем метод для конвертации валют в гривны\r\n    //         this.price = this.price * this.transfer;\r\n\r\n    //     }\r\n\r\n    //     render() { //метод для создания верстки\r\n    //         const element = document.createElement('div'); //создаем элемент, пока он существуект только в скриптах\r\n\r\n    //         if (this.classes.length === 0) { //так как мы для rest оператора не можем назначить значения по дефолту, и он будет в любом случае true, так как даже если не будет введен класс, то он создаст пустой массив, а пустой массив это тру\r\n    //             //то проверяем на длину массива, если он равен нулю, то назначаем значение по умолчанию\r\n    //             this.element = 'menu__item'; //создваем новое свойство для данного элемента значение элемнета\r\n    //             element.classList.add(this.element); //и голворим, что значение нового свойства добавим как новый класс в наш элемент\r\n\r\n    //         } else {\r\n    //             this.classes.forEach(className => element.classList.add(className)); //берем массив классов, перебираем его и каждый класс добавляем нашему новосозданному элементу\r\n\r\n    //         }\r\n    //         // вставляем в наш див нашу html структуру\r\n    //         element.innerHTML = `\r\n    //             <img src=\"${this.src}\" alt=\"${this.alt}\">\r\n    //             <h3 class=\"menu__item-subtitle\">${this.title}</h3>\r\n    //             <div class=\"menu__item-descr\">\r\n    //                 ${this.descr}\r\n    //             </div>\r\n    //             <div class=\"menu__item-divider\"></div>\r\n    //             <div class=\"menu__item-price\">\r\n    //                 <div class=\"menu__item-cost\">Цена:</div>\r\n    //                 <div class=\"menu__item-total\"><span>${this.price}</span> грн/день</div>\r\n    //             </div>\r\n    //         `;\r\n\r\n    //         this.parent.append(element); //говорим что в нашего родителя добавили наш элемент\r\n\r\n    //     }\r\n\r\n    // }\r\n\r\n    // const div1 = new MenuCard(\r\n    //     'img/tabs/vegy.jpg',\r\n    //     'vegy',\r\n    //     'Меню \"Фитнес\"',\r\n    //     'Меню \"Фитнес\" - это новый подход к приготовлению блюд: больше свежих овощей и фруктов. Продукт активных и здоровых людей. Это абсолютно новый продукт с оптимальной ценой и высоким качеством!',\r\n    //     9,\r\n    //     '.menu .container');\r\n\r\n    // const div2 = new MenuCard(\r\n    //     'img/tabs/elite.jpg',\r\n    //     'elite',\r\n    //     'Меню “Премиум”',\r\n    //     'В меню “Премиум” мы используем не только красивый дизайн упаковки, но и качественное исполнение блюд. Красная рыба, морепродукты, фрукты - ресторанное меню без похода в ресторан!',\r\n    //     9,\r\n    //     '.menu .container');\r\n\r\n    // const div3 = new MenuCard(\r\n    //     'img/tabs/post.jpg',\r\n    //     'post',\r\n    //     'Меню \"Постное\"',\r\n    //     'Меню “Постное” - это тщательный подбор ингредиентов: полное отсутствие продуктов животного происхождения, молоко из миндаля, овса, кокоса или гречки, правильное количество белков за счет тофу и импортных вегетарианских стейков.',\r\n    //     9,\r\n    //     '.menu .container');\r\n\r\n    // div1.render();\r\n    // div2.render();\r\n    // div3.render();\r\n\r\n    //---!! способ создания карточек с данными получеными из базы данных !!---\r\n\r\n    // const getResource = async (url) => { //создаем функцию запроса данных для карточек товаров из json файла\r\n    //     let res = await fetch(url); //вызываем fetch с адресом ресурса\r\n\r\n    //     if (!res.ok) { //пишем запрос на статус объекта, если НЕ ок\r\n    //         throw new Error(`Could not fetch ${url}, status: ${res.status}`);\r\n    //     }\r\n    //     return await res.json(); //возвращаем промис в виде js\r\n    // };\r\n\r\n    // // getResource('http://localhost:3000/menu') //вызываем функцию getResources с адресом на нашу базу данных\r\n    // //     .then(data => { //берем полученные данные, которые у нас уже в виде объекта(в нашем случае массива)\r\n    //         // data.forEach(({\r\n    //         //     img,\r\n    //         //     altimg,\r\n    //         //     title,\r\n    //         //     descr,\r\n    //         //     price\r\n    //         // }) => { //используем диструкторизацию объекта, в фиг.скобках, укаазываем свойства объекта, значения которых нам необходимо применить\r\n    //         //     new MenuCard(img, altimg, title, descr, price, '.menu .container').render(); //вызываем наш конструктор MenuCard столько раз, сколько объектов придет с сервера\r\n\r\n\r\n    //         // });\r\n    // //     });\r\n\r\n    // // getResource('http://localhost:3000/menu') //вызываем функцию getResources с адресом на нашу базу данных\r\n    // //     .then(data => createCard(data));\r\n\r\n    // axios.get('http://localhost:3000/menu')\r\n    // .then(data => {\r\n    //     data.data.forEach(({\r\n    //         img,\r\n    //         altimg,\r\n    //         title,\r\n    //         descr,\r\n    //         price\r\n    //     }) => { //используем диструкторизацию объекта, в фиг.скобках, укаазываем свойства объекта, значения которых нам необходимо применить\r\n    //         new MenuCard(img, altimg, title, descr, price, '.menu .container').render(); //вызываем наш конструктор MenuCard столько раз, сколько объектов придет с сервера\r\n\r\n\r\n    //     });\r\n    // });\r\n\r\n    // function createCard(data) { //создаем функцию, которая будет формировать карточки на странице, как атрибут будут данные пришедшие с сервера\r\n    //     data.forEach(({ //перебираем массив объектов полученых с сервера, как аргументы вносим деструктуризацию объекта\r\n    //         img,\r\n    //         altimg,\r\n    //         title,\r\n    //         descr,\r\n    //         price\r\n    //     }) => {\r\n    //         const element = document.createElement('div'); //создаем новый див\r\n    //         element.classList.add('menu__item'); //задем этому элементу класс\r\n    //         // вставляем в наш див нашу html структуру\r\n    //         element.innerHTML = ` \r\n    //             <img src=\"${img}\" alt=\"${altimg}\">\r\n    //             <h3 class=\"menu__item-subtitle\">${title}</h3>\r\n    //             <div class=\"menu__item-descr\">\r\n    //                 ${descr}\r\n    //             </div>\r\n    //             <div class=\"menu__item-divider\"></div>\r\n    //             <div class=\"menu__item-price\">\r\n    //                 <div class=\"menu__item-cost\">Цена:</div>\r\n    //                 <div class=\"menu__item-total\"><span>${price}</span> грн/день</div>\r\n    //             </div>\r\n    //         `;\r\n\r\n    //         document.querySelector('.menu .container').append(element); //вставляем наш новый элемент в меню контейнер\r\n    //     });\r\n    // }\r\n\r\n}\r\n\r\n// module.exports = cards;\r\nexport default cards;","import {\r\n    closeModal,\r\n    openModal\r\n} from './modal'; // импортируем именованые функции из modal\r\nimport {\r\n    postData\r\n} from '../services/services';\r\n\r\nfunction forms(formSelector, modalTimerId) {\r\n    // Отпаравука данных на сервер Forms\r\n\r\n    const form = document.querySelectorAll(formSelector); //берем все формы с нашего сайта\r\n    const message = { //создаем объект с ответами на нашу олтправку формы\r\n        loading: 'icons/spinner.svg', //пока идет заргрузка формы\r\n        success: 'Спасибо! Скоро мы с Вами свяжемся!', //при удачной отправке формы\r\n        failure: 'Что-то пошло не так...' //при ошибке загрузки\r\n    };\r\n\r\n    form.forEach(item => { //перебираем наши формы\r\n        bindPostData(item); //и вызываем отправку формы текущей на сервер\r\n\r\n    });\r\n\r\n\r\n\r\n    function bindPostData(form) { //Функция которая будет отправлять данные на сервер, как аргумент выступает форма для отправки\r\n        form.addEventListener('submit', (e) => { //навешиваем на форму обработчик события сабмит, оно срабатывает при попытке отправить форму\r\n            //событие отправик срабатывает либо при нажатии клавиши Enter, либо при клике на поле у которого стоит type='submit'\r\n            e.preventDefault(); //отменяекм стандартное поведение браузера(перезагрузку страницы при отправке формы)\r\n\r\n            const statusMessage = document.createElement('img'); //создаем новый элекмент на страницек для показа спинера при загрузке\r\n            statusMessage.src = message.loading; //добавляем к картинке аттрибут src в котором будет прописан путь к картинке со спинером\r\n            //прописываем инлайн-стили для нашей картинки со спинером\r\n            statusMessage.style.cssText = `\r\n                    display: block;\r\n                    margin: 0 auto;\r\n                `;\r\n            // form.append(statusMessage); //добавляем этот элемент-сообщение в нашу форму\r\n\r\n            form.insertAdjacentElement('afterend', statusMessage); //добавляем наш спинер в структуру штмл, первый аттрибут указывает куда вставляем(после формы)\r\n            //второй аттрибут что вставляем(наш спинер)\r\n\r\n            //---!! УСТАРЕВШИЙ  способ отправки запросов на сервер\r\n\r\n            // const request = new XMLHttpRequest(); //создаем объект запроса с помощью конструктора XMLHttpRequest\r\n            // request.open('POST', 'server.php'); //открывавем запрос(вводим данные по запросу: тип запроса и путь на который мы будем ссылаться)\r\n            // request.setRequestHeader('Content-type', 'application/json'); //создаем заголовки запроса, что нам будет приходить\r\n\r\n\r\n            const formData = new FormData(form); //формируем новый объект, с помощью конструктора formData который возьмет все данные пользователя из формы\r\n            //как аргумент передаем ту форму из которой нам нужно собрать данные\r\n\r\n            // const object = {}; //создаем пустой объект, в который будут записываться данные из массива FormData\r\n\r\n            // formData.forEach(function (value, key) { //перебираем массив formData и передаем в функцию аргументы - значените и ключ, для формирования объекта\r\n            //     object[key] = value; //берем наш объект и говорим, что ключ(индекс элекмента) объекта равен значению\r\n            // });\r\n\r\n            const json = JSON.stringify(Object.fromEntries(formData.entries())); //превразщаем полученые данные в массив массивов, а потом обратно в объект, а затем в json\r\n\r\n\r\n            // const json = JSON.stringify(object); //конвертируем наш полученный объект в json формат\r\n\r\n            // request.send(json); //отправляем нашу объект, который мы сформировали с помощью json, на сервер\r\n\r\n            //---!! СОВРЕМЕННЫЙ  способ отправки запросов на сервер\r\n\r\n\r\n            postData('http://localhost:3000/requests', json)\r\n                .then(data => { //получаем с сервера какие то данные\r\n                    console.log(data); // выводим ответ на наш запрос\r\n                    showThanksModal(message.success); //вызываем функцию показа сообщений, в котором говорим, что все прошло успешно\r\n                    statusMessage.remove(); //и удаляем спинер со странички\r\n                })\r\n                .catch(() => { //при ошибки отправки запроса\r\n                    // при fetch не сработает c ошибкой в пути, так как получит все равно после запроса true с той только разницей, что в статусе будет false\r\n                    //сработает только с системными ошибками(например отстутствие интернета)\r\n                    showThanksModal(message.failure); //при неудачной загрузке вызываем функцию показа сообщений, в котором говорим, что все прошло плохо\r\n                })\r\n                .finally(() => { //выполняем при любом исходе запроса очистку формы\r\n                    form.reset(); //чистим данные формы, которые ввели\r\n                });\r\n\r\n            // request.addEventListener('load', () => { //на нашу отправку вешаем обработчик события и отслеживаем полную загрузку формы\r\n            //     if (request.status === 200) { //проверяем что статус отправки положительный, все хорошо\r\n            //         console.log(request.response); // выводим ответ на наш запрос\r\n            //         showThanksModal(message.success); //вызываем функцию показа сообщений, в котором говорим, что все прошло успешно\r\n            //         form.reset(); //чистим данные формы, которые ввели\r\n            //         statusMessage.remove(); //и удаляем спинер со странички\r\n            //     } else {\r\n            //         showThanksModal(message.failure); //при неудачной загрузке вызываем функцию показа сообщений, в котором говорим, что все прошло плохо\r\n            //     }\r\n            // });\r\n        });\r\n    }\r\n\r\n    //---Наводим красоту ---\r\n\r\n    function showThanksModal(message) { //создаем функцию, которая выводит(заменяет) модальное окно с сообщением для пользователя\r\n        const prevModalDialog = document.querySelector('.modal__dialog'); //получаем наше модальное окно с сайта\r\n\r\n        prevModalDialog.classList.add('hide'); // добавляем rjyntyne мод. окнf c формой класс hide, который скроет его от пользователя до того как его откроют\r\n        openModal('.modal', modalTimerId); //далее открываем модальное окно \r\n\r\n        const thanksModal = document.createElement('div'); //Zсоздаем новый элемент для модального окна с сообщениями для клиента\r\n        thanksModal.classList.add('modal__dialog'); //добавляем новому элементу класс modal-dialog чтобы подтянулись стили для обертки контентной части модального окна\r\n        //далее в наш блок кладем html-структуру\r\n        thanksModal.innerHTML = `\r\n                <div class=\"modal__content\">\r\n                    <div data-close class=\"modal__close\">&times;</div>\r\n                    <div class=\"modal__title\">${message}</div>\r\n                </div>\r\n    \r\n            `;\r\n\r\n        document.querySelector('.modal').append(thanksModal); //берем элемент модал и добавляем в него наш новый элемент modal-dialog\r\n        setTimeout(() => { //устанавливаем таймер, который будет убирать сообщение и опять показывать форму\r\n            thanksModal.remove(); //убираем сообщение\r\n            prevModalDialog.classList.add('show'); //добавляем класс showи показываем обратно окно с формой\r\n            prevModalDialog.classList.remove('hide'); //убираем класс hide\r\n            closeModal('.modal'); //и закрываем модальное окно полностью\r\n        }, 4000); //через 4 секунды\r\n    }\r\n\r\n    // //---!! API - интерфейс какого-то программного обеспечения, либо приложения !!---\r\n    // //---!! набор каких то инструментов и возможностей, которое нам дает какое то уже готовое решение !!---\r\n    // //---!! DOM API - это различные методы, которые дают нам возможность работать с элементами на странице !!---\r\n    // //---!! FECH API - встроеные в браузер инструмент, который позволяет общаться с сервером с помощью promise !!---\r\n\r\n}\r\n\r\n// module.exports = forms;\r\nexport default forms;\r\n\r\n// //--- GET запрос\r\n\r\n// fetch('https://jsonplaceholder.typicode.com/todos/1') //как аргумент передается тот url на который мы будем посылать запрос\r\n// //в данном случаем мы просто получаем get запрос с этого url\r\n// //вернется именно promise\r\n//     .then(response => response.json()) //обрабатываем полученный промис с помощью then(при удачном выполнении запроса)\r\n//     //вернется тоже promise и если удачно прошло то\r\n//     //в данном случае мы берем ответ и добавляем к нему метод json() который полученный json превратит в обычный объект js\r\n//     .then(json => console.log(json));//при удачной обработке файла мы выводим наш объект в консоль\r\n\r\n// //--- POST запрос\r\n// fetch('https://jsonplaceholder.typicode.com/posts', {\r\n//     method: 'POST', //ОБЯЗАТЕЛЬНОЕ СВОЙСТВО\r\n//     body: JSON.stringify({name: 'Alex'}), //ОБЯЗАТЕЛЬНОЕ СВОЙСТВО\r\n//     headers: { //Желательное свойство, добавляем заголовки, какого типа данные мы отправляем\r\n//         'Content-type': 'application/json'\r\n//     }\r\n// }) //как второй аргумент добавляется объект, с двумя обязательными свойствами - метод (POST), body(тело, данные, которые отправляем)\r\n// //в данном случае оборачиваем новый объект в метод stringify, чтобы он этот объект сконвертировал и добавил в json\r\n// .then(response => response.json()) \r\n// .then(json => console.log(json));\r\n\r\n//---!! NPM-пакеты и JSON-server !!---\r\n//---!! Прежде, чем установить npm пакеты, необходимо развернуть npm-проект  !!---\r\n\r\n// 1 - инциализируем npm - (npm init) - заполняем все поля или пропускаем\r\n// 2 - получаем package.json - в нем содержиться вся информация о проекте и будет информация о подключенных пакетах\r\n// 3 - установка npm пакетов(предпочтительнее устанавливать ЛОКАЛЬНЫЕ пакеты(-g - глобальный, без ярлыка - локальный))\r\n//     npm install - команда которая устанавливает все необходимые пакеты, которые указаны в json афйле\r\n//     --save-dev - указывает, что устанавливаемый пакет будет использован только для разработки\r\n//     --save - указывает, что это обязательный пакет, составляет костяк проекта и необходим внутри пакета\r\n// json-server - (npm i json-server --save-dev) - позволяет работать с json файлами и использовать их как маленькую базу данный, позволяет отправлять и POST-запросы\r\n// запуск json-server - в терминале пишем (npx json-server [файл_который_хотим_использовать]) - пример: json-server db.json\r\n\r\n\r\n//---!! Использование JSON-файла как базу данных !!--\r\n\r\n// fetch('http://localhost:3000/menu') //используем fetch и как путь указываем наш жсон файл, get запрос, который возвращает promise\r\n//     .then(data => data.json()) //возьмем полученый json и превратим его в обычный объект с помощью метода json()\r\n//     .then(result => console.log(result)); //затем полученый результат выводим в консоль","//чтобы код не повторялся два раза. необходимо создать одну функцию с повторяющимся кодом и использовать\r\nfunction closeModal(modalSelector) {\r\n    const modal = document.querySelector(modalSelector);\r\n    modal.classList.add('hide');\r\n    modal.classList.remove('show');\r\n    document.body.style.overflow = '';\r\n}\r\n\r\nfunction openModal(modalSelector, modalTimerId) { //создаем функцию для открытия модального окна\r\n    const modal = document.querySelector(modalSelector);\r\n    modal.classList.add('show');\r\n    modal.classList.remove('hide');\r\n    document.body.style.overflow = 'hidden';\r\n    if (modalTimerId) {\r\n        clearInterval(modalTimerId); //говорим, что если действия выше уже отработали(пользователь сам открыл окно), то таймер отключить\r\n    }\r\n}\r\n\r\nfunction modal(triggerSelector, modalSelector, modalTimerId) {\r\n    //--- Модальное окно ---\r\n\r\n    //Назначаем data-атрибуты для кнопок, по клику на которые будет появляться модальное окно\r\n\r\n    //--- Мой вариант решения ---\r\n\r\n    // const btnModal = document.querySelectorAll('[data-modal]');\r\n    // const btnClose = document.querySelector('[data-close]');\r\n    // const modalWindow = document.querySelector('.modal');\r\n\r\n    // btnModal.forEach(item => {  //перебираем псевдомассив кнопок с дата атрибутом\r\n    //     item.addEventListener('click', () => { //отслеживаем клик по каждой кнопке       \r\n    //         modalWindow.classList.add('show', 'fade');  // говорим, что при клике, для элемента модальное окно, добавляем класс show\r\n    //         modalWindow.classList.remove('hide'); //убрать класс hide\r\n    //     });\r\n    // });\r\n    // btnClose.addEventListener('click', () => { //отслеживаем клик по кнопке close     \r\n    //     modalWindow.classList.add('hide');  // говорим, что при клике, для элемента модальное окно, добавляем класс hide\r\n    //     modalWindow.classList.remove('show', 'fade'); //говорим, чтобы удалил классы show и fade\r\n    // });\r\n\r\n    //--- Решение с преподавателем ---\r\n\r\n    const modalTrigger = document.querySelectorAll(triggerSelector),\r\n        modal = document.querySelector(modalSelector, modalTimerId);\r\n    // modalCloseBtn = document.querySelector('[data-close]'); //---не будет работать с элементами, которые создаются динамически\r\n\r\n\r\n    modalTrigger.forEach(btn => { //перебираем все кнопки\r\n        btn.addEventListener('click', () => //отслеживаем на каждой кнопке клик\r\n            // modal.classList.add('show'); //при клике на кнопку, модальному окну назначаем класс show\r\n            // modal.classList.remove('hide'); // и убираем, если есть класс hide\r\n            // document.body.style.overflow = 'hidden'; // также обращаемся к элементу body и прописываем ему инлайн стиль overflow: hidden, чтобы не прокручивалась страница\r\n            openModal(modalSelector)\r\n        );\r\n    });\r\n\r\n\r\n\r\n    // modalCloseBtn.addEventListener('click', () => {//отслеживаем на кнопке клик\r\n    //     modal.classList.add('hide');//при клике на кнопку, модальному окну назначаем класс hide\r\n    //     modal.classList.remove('show');// и убираем, если есть класс show\r\n    //     document.body.style.overflow = ''; // также обращаемся к элементу body и прописываем ему инлайн стиль overflow(оставляем пустое значение, чтобы браузер сам решил какое значение по дефолту подставить)\r\n\r\n    // });\r\n\r\n    // modalCloseBtn.addEventListener('click', closeModal); //не вызываем функцию, а просто передаем, она сработает только после клика на элемент\r\n\r\n    modal.addEventListener('click', function (e) { //отслеживаем клик на модальное окно\r\n        if (e.target === modal || e.target.getAttribute('data-close') == '') { //проверяем, если событие таргет равно непосредственно модальному окну(серая подложка), \r\n            // или у самого элемента, на который мы кликнули есть аттрибут data-close(равно пустой строке, потому что мы туда ничего не помещаем), то\r\n            // modal.classList.add('hide');//модальному окну назначаем класс hide\r\n            // modal.classList.remove('show');// и убираем, если есть класс show\r\n            // document.body.style.overflow = ''; // также обращаемся к элементу body и прописываем ему инлайн стиль overflow(оставляем пустое значение, чтобы браузер сам решил какое значение по дефолту подставить)    \r\n            closeModal(modalSelector); //а здесь функцию именно вызываем, так как нам надо ее выполнить только после того как выполнится условие\r\n        }\r\n    });\r\n\r\n    document.addEventListener('keydown', (e) => { //отслеживаем нажатие клавиши на клавиатуре и передаем объект события\r\n        if (e.code === 'Escape' && modal.classList.contains('show')) { //если код клавиши по которой кликнули равна строке искейп,\r\n            //и так же проверяем содержит ли можальное окно класс show\r\n            closeModal(modalSelector); //если условия соблюдены, то закрываем модальное окно\r\n        }\r\n    });\r\n\r\n\r\n    //--- Модификации модального окна ---\r\n    //--- Вызываем модальное окно через определенный промежуток времени ---\r\n\r\n    //--- задача,если пользователь долистал страницу до конца, то открываем модальное окно ---\r\n\r\n    function showModalByScroll() { //создаем функцию, открытия окна при скроллинге страницы вниз\r\n        if (window.pageYOffset + document.documentElement.clientHeight >= document.documentElement.scrollHeight - 1) {\r\n            //если высоте пролистанного контента(невидимого) + высота видимого контента больше или равно высоте всего документа(видимая и невидимая часть)\r\n            openModal(modalSelector, modalTimerId);\r\n            window.removeEventListener('scroll', showModalByScroll); //говорим, что для окна браузера после того как окно модальное было ужек открыто,\r\n            // мы убираем отслеживание события скролл и отработку функции открытия окна модального\r\n        }\r\n    }\r\n\r\n    window.addEventListener('scroll', showModalByScroll); //отслеживаем скроллинг страницы и после этого определяем функцию открытия можального окна\r\n\r\n\r\n}\r\n\r\n// module.exports = modal;\r\nexport default modal; //создаем один дефолтный модуль\r\nexport {\r\n    closeModal\r\n};\r\nexport {\r\n    openModal\r\n}; //и два именованых","function slider({\r\n    container,\r\n    slide,\r\n    nextArrow,\r\n    prevArrow,\r\n    totalCounter,\r\n    currentCounter,\r\n    wrapper,\r\n    field\r\n}) {\r\n\r\n\r\n    //---SLIDER V1 ---\r\n\r\n    //--- Мой код, НЕ зарабюотал ---\r\n\r\n    // const prevArrow = document.querySelector('.offer__slider-prev'),\r\n    //       nextArrow = document.querySelector('.offer__slider-next'),\r\n    //       parentArrows = document.querySelector('offer__slider-counter'),\r\n    //       currentCounter = document.querySelector('#current'),\r\n    //       totalCounter = document.querySelector('#total'),\r\n    //       sliderItems = document.querySelectorAll('.offer__slide');\r\n\r\n    //     console.log(sliderItems);\r\n\r\n    //     function startSliderItem() {\r\n    //         sliderItems.forEach((item, i) => {\r\n    //             if(i === 0) {\r\n    //                 item.classList.add('show');\r\n    //                 item.classList.remove('hide');\r\n    //                 if(i+1 < 10) {\r\n    //                     currentCounter.innerHTML = `0${i+1}`;\r\n    //                 } else {\r\n    //                     currentCounter.innerHTML = `${i+1}`;\r\n    //                 }  \r\n    //             } else {\r\n    //                 item.classList.add('hide');\r\n    //             }        \r\n    //         });\r\n    //     }\r\n\r\n\r\n\r\n    // function checkNumberItems(arrow, box) {\r\n    //     const arrowItems = sliderItems.length;\r\n    //     if(arrowItems < 10) {\r\n    //         box.innerHTML = `0${arrowItems}`;\r\n    //     } else {\r\n    //         box.innerHTML = `${arrowItems}`;\r\n    //     }        \r\n    // }    \r\n\r\n    // function nextSlide() {\r\n    //     nextArrow.addEventListener('click', (event) => {\r\n    //         const target = event.target; \r\n\r\n    //         if(target && target.classList.contains('offer__slider-next')) {\r\n    //             const num = + currentCounter.innerHTML;\r\n    //             const index = num -1;\r\n\r\n    //             console.log(num);\r\n    //             console.log(index);\r\n    //             console.log(sliderItems.length);\r\n    //             if(num > sliderItems.length - 1) {\r\n    //                 startSliderItem();\r\n    //             }  else {\r\n\r\n    //                 sliderItems[index].classList.add('hide');\r\n    //                 sliderItems[index].classList.remove('show');\r\n    //                 sliderItems[num].classList.add('show');\r\n    //                 sliderItems[num].classList.remove('hide');\r\n    //                 if(num + 1 < 10) {\r\n    //                     currentCounter.innerHTML = `0${num + 1}`;\r\n    //                 } else {\r\n    //                     currentCounter.innerHTML = `${num + 1}`;\r\n    //                 }\r\n\r\n    //             }\r\n\r\n\r\n    //         }\r\n\r\n\r\n    //     });\r\n    // }\r\n\r\n    // function prevSlide() {\r\n    //     prevArrow.addEventListener('click', (event) => {\r\n    //         const target = event.target; \r\n\r\n    //         if(target && target.classList.contains('offer__slider-prev')) {\r\n    //             let num = + currentCounter.innerHTML;\r\n    //             let index = num - 1;\r\n\r\n    //             if(num < 2) {\r\n    //                 num = + sliderItems.length -1;\r\n    //                 index = num - 1;\r\n    //             }  \r\n    //             console.log(num);\r\n    //             console.log(index);\r\n    //             console.log('prev');\r\n\r\n    //             sliderItems[index].classList.add('hide');\r\n    //             sliderItems[index].classList.remove('show');\r\n    //             sliderItems[index - 1].classList.add('show');\r\n    //             sliderItems[index - 1].classList.remove('hide');\r\n    //             if(num - 1 < 10) {\r\n    //                 currentCounter.innerHTML = `0${num - 1}`;\r\n    //             } else {\r\n    //                 currentCounter.innerHTML = `${num - 1}`;\r\n    //             }\r\n\r\n\r\n    //         } \r\n\r\n    //     });\r\n    // }\r\n\r\n\r\n    // function showSliderItem() {\r\n    //     startSliderItem();\r\n    //     nextSlide();\r\n    //     prevSlide();\r\n\r\n    // }\r\n    // showSliderItem();\r\n\r\n    // checkNumberItems(sliderItems, totalCounter);\r\n\r\n\r\n    //--- Вариант преподавателя ---\r\n\r\n    const slides = document.querySelectorAll(slide),\r\n        slider = document.querySelector(container),\r\n        prev = document.querySelector(prevArrow),\r\n        next = document.querySelector(nextArrow),\r\n        total = document.querySelector(totalCounter),\r\n        current = document.querySelector(currentCounter),\r\n        slidesWrapper = document.querySelector(wrapper),\r\n        slidesField = document.querySelector(field),\r\n        width = window.getComputedStyle(slidesWrapper).width; //обращаемся к окнцу браузера и просим данные о стилях, которые были применены уже к определенным блокам\r\n    //(в данном случае обертке слайдера и получаем ширину)\r\n    let slideIndex = 1,\r\n        offset = 0; //переменная показывающая сколько мы уже отступили\r\n\r\n\r\n\r\n    //--- slider 2 ---\r\n\r\n    if (slides.length < 10) {\r\n        total.textContent = `0${slides.length}`;\r\n        current.textContent = `0${slideIndex}`;\r\n    } else {\r\n        total.textContent = slides.length;\r\n        current.textContent = slideIndex;\r\n    }\r\n\r\n    slidesField.style.width = 100 * slides.length + '%'; //задаем для контейнера всех слайдеров ширину равную количество слайдов * 100%\r\n    //так как каждый слайд будет занимать 100% видимого родителя\r\n    slidesField.style.display = 'flex'; //меняем для контейнера слайдов дисплей на флекс, чтобы слайды выстроились в ряд\r\n    slidesField.style.transition = '0.5s all'; //и говорим, что слайды заменяться должны плавно\r\n\r\n    slidesWrapper.style.overflow = 'hidden'; //для видимого родителя назначаем overflow:hidden, чтобы обрезать лишние файлы\r\n\r\n    slides.forEach(slide => { //перебираем каждый слайд\r\n        slide.style.width = width; //каждому слайду назначаем ширину равную ширине видимого родителя\r\n    });\r\n\r\n    slider.style.position = 'relative';\r\n    const indicators = document.createElement('ol'),\r\n        dots = [];\r\n\r\n\r\n    indicators.classList.add('carousel-indicators');\r\n    slider.append(indicators);\r\n\r\n    for (let i = 0; i < slides.length; i++) {\r\n        const dot = document.createElement('li');\r\n        dot.classList.add('dot');\r\n        dot.setAttribute('data-slide-to', i + 1);\r\n        //добавляем к li data-фттрибут со значением равным i+1((индекс в массиве + 1))\r\n        if (i == 0) {\r\n            dot.style.opacity = 1;\r\n        }\r\n\r\n        indicators.append(dot);\r\n        dots.push(dot);\r\n    }\r\n\r\n    function deleteNotDigits(str) {\r\n        return +str.replace(/\\D/g, '');\r\n    }\r\n\r\n    next.addEventListener('click', () => { //сдвиг слайдера на следующий слайд\r\n        //делаем проверку не дошел ли слайдер до последнего слайда\r\n        if (offset == deleteNotDigits(width) * (slides.length - 1)) { //если наш отступ равен ширине всех наших слайдов(то есть дошли до конца слайдов)\r\n            //+width - превращаем строку в числовойтип данных\r\n            //затем вырезаем из строки ширины все символы начиная с нулевого заканчивая 3им с конца\r\n            //то есть два крайних, которые в строке (px) выкидываем\r\n            offset = 0; //то устанавливаем ему значение 0(то есть говорим отсчитывать слайды сначала)\r\n        } else { //если отступ не дошел до конца\r\n            offset += deleteNotDigits(width); //мы к нему прибавляем ширину одного слайда, то есть сдвигаем на шаг\r\n        }\r\n\r\n        slidesField.style.transform = `translateX(-${offset}px)`;\r\n        //обращаемся к контейнеру слайдеров и говорим, что он должен сдвинуться влево на определенное количесатво пикселей\r\n\r\n        if (slideIndex == slides.length) {\r\n            slideIndex = 1;\r\n        } else {\r\n            slideIndex++;\r\n        }\r\n\r\n        if (slides.length < 10) {\r\n            current.textContent = `0${slideIndex}`;\r\n        } else {\r\n            current.textContent = slideIndex;\r\n        }\r\n\r\n        dots.forEach(dot => dot.style.opacity = '.5');\r\n        dots[slideIndex - 1].style.opacity = 1;\r\n\r\n    });\r\n\r\n    prev.addEventListener('click', () => { //сдвиг слайдера на следующий слайд\r\n        //делаем проверку не дошел ли слайдер до последнего слайда\r\n        if (offset == 0) {\r\n            offset = deleteNotDigits(width) * (slides.length - 1);\r\n        } else {\r\n            offset -= deleteNotDigits(width);\r\n        }\r\n\r\n        slidesField.style.transform = `translateX(-${offset}px)`;\r\n\r\n        if (slideIndex == 1) {\r\n            slideIndex = slides.length;\r\n        } else {\r\n            slideIndex--;\r\n        }\r\n\r\n        if (slides.length < 10) {\r\n            current.textContent = `0${slideIndex}`;\r\n        } else {\r\n            current.textContent = slideIndex;\r\n        }\r\n\r\n        dots.forEach(dot => dot.style.opacity = '.5');\r\n        dots[slideIndex - 1].style.opacity = 1;\r\n    });\r\n\r\n    dots.forEach(dot => {\r\n        dot.addEventListener('click', (e) => {\r\n            const slideTo = e.target.getAttribute('data-slide-to');\r\n            //получаем значение аттрибута того элемента по которому кликнули\r\n\r\n            slideIndex = slideTo;\r\n            offset = deleteNotDigits(width) * (slideTo - 1);\r\n\r\n            slidesField.style.transform = `translateX(-${offset}px)`;\r\n\r\n\r\n            if (slides.length < 10) {\r\n                current.textContent = `0${slideIndex}`;\r\n            } else {\r\n                current.textContent = slideIndex;\r\n            }\r\n\r\n            dots.forEach(dot => dot.style.opacity = '.5');\r\n            dots[slideIndex - 1].style.opacity = 1;\r\n\r\n\r\n        });\r\n    });\r\n}\r\n\r\n// module.exports = slider;\r\nexport default slider;","function tabs(tabsSelector, tabsContentSelector, tabsParentSelector, activeClass) {\r\n    // --- Tabs ---\r\n\r\n    //--- Создаем переменные ---\r\n\r\n    const tabs = document.querySelectorAll(tabsSelector), //получаем псевдомассив табов из меню\r\n        tabsContent = document.querySelectorAll(tabsContentSelector), //получаем псевдомассив блоков с контентом табов\r\n        tabsParent = document.querySelector(tabsParentSelector); // получаем родителя всех табов из меню\r\n\r\n    //--- Скрываем ненужный контент для табов и убираем класс active с самих табов ---\r\n\r\n    function hideTabContent() {\r\n        tabsContent.forEach(item => { //перебираем псевдомассив блоков с контентом, берем каждый отдельно\r\n            // item.style.display = 'none'; //обращаемся к свойству style и прописываем ему в свойство display значение none(инлайновые стили)\r\n            item.classList.remove('show', 'fade');\r\n            item.classList.add('hide');\r\n        });\r\n\r\n        tabs.forEach(item => { //перебираем псевдомассив табов\r\n            item.classList.remove(activeClass); //берем каждый таб, обращаемся к объекту класслист и задаем метод ремув - удаляем указанный класс\r\n        });\r\n    }\r\n\r\n    //--- Показываем нужный контент для табов и добавляем класс active на нужный нам тьаб ---\r\n\r\n    function showTabContent(i = 0) { //стандарт es6, если не передается аргумент, то подставится 0\r\n        // tabsContent[i].style.display = 'block'; //прописываем для конкретного блока с контентом инлайновый стиль дисплей блок\r\n        tabsContent[i].classList.remove('hide');\r\n        tabsContent[i].classList.add('show', 'fade');\r\n        tabs[i].classList.add(activeClass); //для конкретнгого таба добавляем класс активности\r\n    }\r\n\r\n    //--- вызываем функции ---\r\n\r\n    hideTabContent();\r\n    showTabContent();\r\n\r\n    //--- используем делегирование, отслеживаем клик на один из табов, задаем ему классактивности  и открываем нужный таб ---\r\n\r\n    tabsParent.addEventListener('click', (event) => { //отслеживаем клик в родителе табов\r\n        const target = event.target; //создаем переменную с объектом таргет\r\n\r\n        if (target && target.classList.contains(tabsSelector.slice(1))) { //проверяем есть ли вообще объект таргет у события и проверяем соответствие класса, по тому ли элементу мы кликнули\r\n            tabs.forEach((item, i) => { //перебираем псевдомассив всех табов, берем таб и его индекс\r\n                if (target == item) { //если объект таргет равен нашему данному элементу\r\n                    hideTabContent();\r\n                    showTabContent(i); //переключаем табы\r\n                }\r\n\r\n            });\r\n\r\n        }\r\n\r\n    });\r\n}\r\n\r\n// module.exports = tabs;\r\nexport default tabs;","function timer(id, deadline) {\r\n    //--- Timer ---\r\n    function getTimeRemaining(endtime) { //созда ем функцию, которая будет вычислять сколько времени между сегодняшним днем и окончанием акции\r\n        const t = Date.parse(endtime) - Date.parse(new Date()),\r\n            //создаем техническую переменную, в  которой передаем разницу между окончанием акции в миллисекундах и текущей даты в миллисекундах\r\n            days = Math.floor(t / (1000 * 60 * 60 * 24)), //переводим миллисекунды в количество дней\r\n            //создаем переменную, которая роавна -> округляем до целого деление (нашей разницы во времени на произведение ->)\r\n            // 1000миллисекунд * 60 (секунд) * 60часов * 24часа в сутках => столько миллисекунд в сутках\r\n            hours = Math.floor((t / (1000 * 60 * 60) % 24)), //переводим миллисекунды в количество часов\r\n            //миллисекунды разницы течения нашей акции деленная на произведение 1000миллисекунд * 60сек * 60мин => получим всю акцию в часах\r\n            //поскольку нам нужен остаток часов менее суток, то %24 делим с остатком на 24 и этот остаток округляем до целого - получаем часы\r\n            minutes = Math.floor((t / (1000 * 60) % 60)), //получаем остаток менее часа  - оставшиеся минуты акции\r\n            seconds = Math.floor((t / 1000) % 60); //получаем секунда - остаток меньше минуты\r\n\r\n        return { //возвращаем полученные данные в виде объекта\r\n            'total': t,\r\n            'days': days,\r\n            'hours': hours,\r\n            'minutes': minutes,\r\n            'seconds': seconds\r\n        };\r\n    }\r\n\r\n    function getZero(num) { //функция, которое будет просверять число, если оно меньше 10, то спереди будет добавлять 0\r\n        if (num >= 0 && num < 10) { //если наше число  больше или ровно 0 И меньше 10\r\n            return `0${num}`; //то возвращаем вместо числа строку с 0 впереди\r\n        } else {\r\n            return num; //иначе ничего не модифицируем, а просто возвращаем число\r\n        }\r\n    }\r\n\r\n    function setClock(selector, endtime) { //устанавливаем наши часы на сайте\r\n        const timer = document.querySelector(selector), //берем элемент с таймером со страницы\r\n            days = timer.querySelector('#days'), //элемент для записи дней\r\n            hours = timer.querySelector('#hours'), //элемент для записи часов\r\n            minutes = timer.querySelector('#minutes'), //элемент для записи минут\r\n            seconds = timer.querySelector('#seconds'), //элемент для записи секунд\r\n            timeInterval = setInterval(updateClock, 1000); //говорим что функцию обновления счетчика надо обновлять каждую секунду\r\n\r\n        updateClock(); //вызываем функцию первый раз, чтобы не ждать обновления таймера 1000миллисекунд\r\n\r\n        function updateClock() { //создаем функцию, которая будет обновлять наш счетчик каждую секунду\r\n            const t = getTimeRemaining(endtime); //получаем наш объект с оставшимися днями минутами часами\r\n\r\n            days.innerHTML = getZero(t.days); // в элемент с индетификатором days записываем данные из рассчитанного выше объекта свойство days\r\n            hours.innerHTML = getZero(t.hours); //записываем оставшиеся часы\r\n            minutes.innerHTML = getZero(t.minutes); //записываем оставшиеся минуты\r\n            seconds.innerHTML = getZero(t.seconds); //записываем оставшиеся секунды\r\n\r\n            if (t.total <= 0) { //если общее колличество миллисекунд меньше или равно 0\r\n                clearInterval(timeInterval); //останавливаем обновление нашей функции\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n    setClock(id, deadline);\r\n}\r\n\r\n// module.exports = timer;\r\nexport default timer;","const postData = async (url, data) => { //создаем функцию, которая постит наши данные, как переменные вводим адрес запроса и данные, которые будут поститься\r\n    //с помощью async мы говорим, что внутри функции будет асинхронный код\r\n    //async - прописывается перед  функцией в которой будет какой-то асинхронный код\r\n    //а await - перед кодом, которого необходимо дождаться, перед тем как дальше выполнять функцию\r\n    let res = await fetch(url, {\r\n        method: 'POST', //метод отправки POST- запрос\r\n        headers: { //прописываем заголовки\r\n            'Content-type': 'application/json'\r\n        },\r\n        body: data //и как тело отправки указываем наш объект formData \r\n    }); //получаем promise который нам возвращает fetch\r\n\r\n    return await res.json(); //возвращаем промис в виде json\r\n};\r\n\r\nexport {\r\n    postData\r\n};","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","'use strict';\r\n\r\nrequire('es6-promise').polyfill();\r\n\r\nimport tabs from './modules/tabs';\r\nimport calc from './modules/calc';\r\nimport cards from './modules/cards';\r\nimport forms from './modules/forms';\r\nimport modal from './modules/modal';\r\nimport slider from './modules/slider';\r\nimport timer from './modules/timer';\r\nimport openModal from './modules/modal';\r\n\r\nwindow.addEventListener('DOMContentLoaded', () => { //отслеживаем загрузку контента на странице\r\n\r\n    const modalTimerId = setTimeout(() => openModal('.modal', modalTimerId), 50000); //создаем таймер отработки функции по открытию можального окна, говорим чтобы сработала она через 3 секунды\r\n\r\n\r\n    // const tabs = require('./modules/tabs'),\r\n    //     calc = require('./modules/calc'),\r\n    //     cards = require('./modules/cards'),\r\n    //     forms = require('./modules/forms'),\r\n    //     modal = require('./modules/modal'),\r\n    //     slider = require('./modules/slider'),\r\n    //     timer = require('./modules/timer');\r\n\r\n\r\n\r\n    tabs('.tabheader__item', '.tabcontent', '.tabheader__items', 'tabheader__item_active');\r\n    calc();\r\n    cards();\r\n    forms('form', modalTimerId);\r\n    modal('[data-modal]', '.modal', modalTimerId);\r\n    slider({\r\n        container: '.offer__slider',\r\n        slide: '.offer__slide',\r\n        nextArrow: '.offer__slider-next',\r\n        prevArrow: '.offer__slider-prev',\r\n        totalCounter: '#total',\r\n        currentCounter: '#current',\r\n        wrapper: '.offer__slider-wrapper',\r\n        field: '.offer__slider-inner'\r\n    });\r\n\r\n\r\n    timer('.timer', '2022-06-11');\r\n\r\n});"],"names":[],"sourceRoot":""}